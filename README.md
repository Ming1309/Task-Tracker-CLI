# üéØ Task Tracker CLI - C++23 Modern Implementation

M·ªôt ·ª©ng d·ª•ng Task Tracker CLI ƒë∆∞·ª£c x√¢y d·ª±ng ƒë·ªÉ showcase 10 k·ªπ thu·∫≠t m·ªõi c·ªßa C++23, ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a ƒë·ªÉ bi√™n d·ªãch v·ªõi Clang.

## üöÄ C√°c T√≠nh NƒÉng

- ‚úÖ Qu·∫£n l√Ω task v·ªõi tr·∫°ng th√°i (Pending, In Progress, Completed, Cancelled)
- ‚úÖ Thi·∫øt l·∫≠p priority v√† category cho task
- ‚úÖ T√¨m ki·∫øm v√† s·∫Øp x·∫øp task theo nhi·ªÅu ti√™u ch√≠
- ‚úÖ Th·ªëng k√™ chi ti·∫øt v·ªÅ task completion rate
- ‚úÖ Giao di·ªán CLI th√¢n thi·ªán v·ªõi emoji v√† formatting

## üîß Build Instructions

```bash
# Clone v√† build project
mkdir build && cd build
cmake .. -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=Debug
make

# Run ·ª©ng d·ª•ng
./NewTechniquesCpp23
```

## üìã C√°c L·ªánh CLI

| L·ªánh | M√¥ t·∫£ | V√≠ d·ª• |
|------|-------|-------|
| `add` | Th√™m task m·ªõi | `add "Buy groceries" "Get milk and bread"` |
| `list` | Li·ªát k√™ t·∫•t c·∫£ task ho·∫∑c theo status | `list`, `list pending` |
| `complete` | ƒê√°nh d·∫•u task ho√†n th√†nh | `complete 1` |
| `remove` | X√≥a task | `remove 2` |
| `status` | Thay ƒë·ªïi tr·∫°ng th√°i task | `status 1 progress` |
| `priority` | Thi·∫øt l·∫≠p priority | `priority 1 5` |
| `category` | Thi·∫øt l·∫≠p category | `category 1 Shopping` |
| `find` | T√¨m ki·∫øm task theo t·ª´ kh√≥a | `find grocery` |
| `sort` | S·∫Øp x·∫øp task | `sort priority`, `sort created`, `sort title` |
| `stats` | Hi·ªÉn th·ªã th·ªëng k√™ | `stats` |
| `save` | L∆∞u tasks v√†o file JSON | `save tasks.json` |
| `load` | T·∫£i tasks t·ª´ file JSON | `load tasks.json` |
| `help` | Hi·ªÉn th·ªã help | `help` |
| `exit` | Tho√°t ·ª©ng d·ª•ng | `exit` |

## üéØ 10 K·ªπ Thu·∫≠t C++23 ƒê∆∞·ª£c S·ª≠ D·ª•ng

### 1. **Enhanced Enum Classes v·ªõi Underlying Type Deduction**
```cpp
enum class TaskStatus : std::uint8_t {
    Pending,
    InProgress, 
    Completed,
    Cancelled
};
```
- Enum classes m·∫°nh m·∫Ω h∆°n v·ªõi ki·ªÉu d·ªØ li·ªáu underlying r√µ r√†ng
- Memory-efficient v√† type-safe

### 2. **Concepts for Type Constraints**
```cpp
template<typename T>
concept Stringable = requires(T t) {
    { t.to_string() } -> std::convertible_to<std::string>;
};

template<typename T>
concept TaskLike = requires(T t) {
    { t.getId() } -> std::convertible_to<int>;
    { t.getTitle() } -> std::convertible_to<std::string>;
    { t.getStatus() } -> std::convertible_to<TaskStatus>;
};
```
- R√†ng bu·ªôc ki·ªÉu d·ªØ li·ªáu m·∫°nh m·∫Ω v√† c√≥ th·ªÉ ƒë·ªçc hi·ªÉu
- Better template error messages

### 3. **std::expected for Error Handling**
```cpp
using TaskResult = std::expected<bool, TaskError>;
using TaskOptional = std::expected<Task, TaskError>;

TaskResult addTask(const std::string& title, const std::string& description = "");
```
- Thay th·∫ø exceptions b·∫±ng functional error handling
- Performance t·ªët h∆°n v√† explicit error handling
- *(Note: S·ª≠ d·ª•ng polyfill v√¨ clang ch∆∞a h·ªó tr·ª£ ho√†n to√†n)*

### 4. **Enhanced Structured Bindings v·ªõi Pack Expansion**
```cpp
struct TaskMetadata {
    std::chrono::system_clock::time_point created_at;
    std::chrono::system_clock::time_point updated_at;
    std::optional<std::chrono::system_clock::time_point> completed_at;
    std::string category;
    int priority = 0;
    
    auto tie() const {
        return std::tie(created_at, updated_at, completed_at, category, priority);
    }
};
```
- Structured bindings m·∫°nh m·∫Ω h∆°n cho data manipulation
- Easy serialization/deserialization

### 5. **Defaulted Comparison Operators v·ªõi Auto**
```cpp
bool operator==(const Task& other) const {
    return id_ == other.id_ && title_ == other.title_ && status_ == other.status_;
}

bool operator<(const Task& other) const {
    if (id_ != other.id_) return id_ < other.id_;
    if (title_ != other.title_) return title_ < other.title_;
    return static_cast<int>(status_) < static_cast<int>(other.status_);
}
```
- Auto-generated comparison operators
- Consistent v√† efficient comparisons

### 6. **Modern Getter Methods (Explicit Object Parameter Simulation)**
```cpp
int getId() const { return id_; }
const std::string& getTitle() const { return title_; }
// ...with both const and non-const versions
```
- Clean interface design
- Perfect forwarding simulation for better performance

### 7. **std::format Integration**
```cpp
std::string Task::to_string() const {
    std::ostringstream oss;
    oss << std::format("Task [ID: {}]\n", id_);
    oss << std::format("  Title: {}\n", title_);
    oss << std::format("  Status: {}\n", taskStatusToString(status_));
    // ...
    return oss.str();
}
```
- Modern string formatting thay th·∫ø printf/iostreams
- Type-safe v√† readable
- *(Note: S·ª≠ d·ª•ng iostreams + format cho compatibility)*

### 8. **Spaceship Operator (Three-way Comparison)**
```cpp
// Simulated spaceship operator behavior
bool operator<(const Task& other) const {
    if (id_ != other.id_) return id_ < other.id_;
    if (title_ != other.title_) return title_ < other.title_;
    return static_cast<int>(status_) < static_cast<int>(other.status_);
}
```
- M·ªôt operator cho t·∫•t c·∫£ comparisons
- Consistent v√† efficient sorting

### 9. **Ranges v√† Views Integration**
```cpp
auto getTasksByStatus(TaskStatus status) const {
    return filterTasks([status](const Task& task) {
        return task.getStatus() == status;
    });
}

template<std::predicate<const Task&> Predicate>
auto filterTasks(Predicate&& pred) const {
    return tasks_ | std::views::filter(std::forward<Predicate>(pred));
}
```
- Functional programming style v·ªõi ranges
- Lazy evaluation v√† composable operations
- Memory efficient data processing

### 10. **Enhanced Lambda Expressions v·ªõi Template Parameters**
```cpp
commands_["add"] = Command{
    .name = "add",
    .description = "Add a new task (add \"title\" [description])",
    .handler = [this](const auto& args) { handleAdd(args); },
    .min_args = 1,
    .max_args = 2
};

template<typename Compare>
requires std::strict_weak_order<Compare, Task, Task>
std::vector<Task> getSortedTasks(Compare&& comp) const {
    auto sorted_tasks = tasks_;
    std::ranges::sort(sorted_tasks, std::forward<Compare>(comp));
    return sorted_tasks;
}
```
- Generic lambdas v·ªõi template constraints
- Designated initializers cho clean syntax
- Perfect forwarding trong lambdas

## üîç C√°c T√≠nh NƒÉng B·ªï Sung

### Designated Initializers
```cpp
Command{
    .name = "add",
    .description = "Add a new task",
    .handler = [this](const auto& args) { handleAdd(args); },
    .min_args = 1,
    .max_args = 2
};
```

### Advanced Template Metaprogramming
```cpp
template<typename Compare>
requires std::strict_weak_order<Compare, Task, Task>
std::vector<Task> getSortedTasks(Compare&& comp) const;
```

### Modern Error Handling Patterns
```cpp
if (result) {
    std::cout << "‚úÖ Success!\n";
} else {
    handleError(result.error());
}
```

## üé® Code Style v√† Conventions

### Naming Conventions
- **Private member variables**: S·ª≠ d·ª•ng ti·ªÅn t·ªë `_` (underscore prefix)
  ```cpp
  class Task {
  private:
      int _id;                    // ‚úÖ Correct
      std::string _title;         // ‚úÖ Correct  
      TaskStatus _status;         // ‚úÖ Correct
      TaskMetadata _metadata;     // ‚úÖ Correct
  };
  ```

- **Public methods**: CamelCase
  ```cpp
  int getId() const;              // ‚úÖ Correct
  void setTitle(const std::string& title);  // ‚úÖ Correct
  ```

- **Constants v√† Enums**: PascalCase
  ```cpp
  enum class TaskStatus {
      Pending,                    // ‚úÖ Correct
      InProgress,                 // ‚úÖ Correct
      Completed                   // ‚úÖ Correct
  };
  ```

## üõ†Ô∏è Ki·∫øn Tr√∫c Technical

- **Separation of Concerns**: Task logic t√°ch bi·ªát v·ªõi CLI logic
- **RAII**: Automatic resource management
- **Modern C++ Idioms**: Smart pointers, move semantics, perfect forwarding
- **Template Metaprogramming**: Concepts v√† constraints
- **Functional Programming**: Ranges, algorithms, lambdas

## üìä Performance Features

- **Memory Efficient**: Enum classes v·ªõi fixed underlying types
- **Cache Friendly**: Contiguous memory layout v·ªõi std::vector
- **Lazy Evaluation**: Ranges views kh√¥ng copy data
- **Move Semantics**: Efficient object transfers
- **Template Specialization**: Zero-cost abstractions

## üé® User Experience

- **Rich CLI Interface**: Emoji v√† colors
- **Intuitive Commands**: Natural language-like syntax
- **Error Handling**: Clear error messages
- **Help System**: Comprehensive documentation
- **Flexible Input**: Quoted strings support

## üß™ Testing

```bash
# Build v√† run
cd build && make && ./NewTechniquesCpp23

# Test c√°c commands
add "Test Task" "This is a test"
list
priority 1 5
complete 1
stats
exit
```

## üìù Notes v·ªÅ Compatibility

- Code ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a cho **Clang 14+** v√† **GCC 11+**
- M·ªôt s·ªë t√≠nh nƒÉng C++23 ƒë∆∞·ª£c simulate ƒë·ªÉ ƒë·∫£m b·∫£o compatibility
- Build system s·ª≠ d·ª•ng CMake v·ªõi C++23 standard
- Cross-platform support (macOS, Linux, Windows)

---

**T√°c gi·∫£**: ·ª®ng d·ª•ng showcase c√°c k·ªπ thu·∫≠t C++23 ti√™n ti·∫øn  
**Phi√™n b·∫£n**: 1.0.0  
**License**: MIT

### 2. **std::print** - In ·∫•n ƒë∆∞·ª£c c·∫£i thi·ªán
```cpp
std::print("‚úÖ Task added successfully with ID: {}\n", task_id);
```
C·∫£i thi·ªán hi·ªáu su·∫•t v√† ergonomics so v·ªõi std::cout.

### 3. **Multidimensional subscript operator** - To√°n t·ª≠ ch·ªâ m·ª•c ƒëa chi·ªÅu
```cpp
auto operator[](std::size_t id, std::string_view field) const 
    -> std::expected<std::string, TaskError>;
```
Cho ph√©p truy c·∫≠p d·ªØ li·ªáu theo nhi·ªÅu chi·ªÅu: `task_manager[1, "description"]`

### 4. **if consteval** - Ki·ªÉm tra th·ªùi gian bi√™n d·ªãch
```cpp
template<typename T>
auto set_priority(T priority) -> std::expected<void, TaskError> {
    if consteval {
        static_assert(std::is_same_v<T, Priority> || std::is_integral_v<T>);
    }
    // ...
}
```
Ph√¢n bi·ªát code ch·∫°y compile-time vs runtime.

### 5. **auto(x)** - Decay copy
```cpp
auto clone() const -> Task {
    return Task{auto(id_), auto(description_), auto(priority_)};
}
```
T·∫°o copy r√µ r√†ng v·ªõi decay semantics.

### 6. **Explicit object parameter (deducing this)** - Tham s·ªë ƒë·ªëi t∆∞·ª£ng t∆∞·ªùng minh
```cpp
template<typename Self>
auto get_id(this Self&& self) -> std::size_t {
    return self.id_;
}
```
Lo·∫°i b·ªè code duplication cho const/non-const overloads.

### 7. **std::mdspan** - Multi-dimensional array view
```cpp
std::mdspan<int, std::dextents<std::size_t, 2>> matrix_view{
    task_data.data(), tasks_.size(), 2uz
};
```
View ƒëa chi·ªÅu hi·ªáu qu·∫£ cho d·ªØ li·ªáu.

### 8. **Literal suffix for size_t** - H·∫≠u t·ªë literal cho size_t
```cpp
constexpr std::size_t DEFAULT_CAPACITY = 100uz;
for (std::size_t i = 0uz; i < matrix_view.extent(0); ++i)
```
Literal r√µ r√†ng cho size_t ƒë·ªÉ tr√°nh warnings.

### 9. **Contains function for associative containers** - H√†m contains
```cpp
auto task_exists(std::size_t id) const -> bool {
    return id_to_index_.contains(id);
}
```
Ki·ªÉm tra s·ª± t·ªìn t·∫°i ƒë∆°n gi·∫£n h∆°n so v·ªõi find().

### 10. **Improved constexpr support** - H·ªó tr·ª£ constexpr ƒë∆∞·ª£c c·∫£i thi·ªán
```cpp
consteval auto get_max_priority() -> int {
    return 10;
}
```
Nhi·ªÅu thu·∫≠t to√°n v√† containers h·ªó tr·ª£ constexpr.

## üõ†Ô∏è Build Instructions

### Prerequisites
- C++23 compatible compiler:
  - GCC 13+ 
  - Clang 16+
  - MSVC 2022 (17.4+)
- CMake 3.20+

### Build Commands
```bash
mkdir build && cd build
cmake ..
make
```

### Run
```bash
./NewTechniquesCpp23
```

## üìã Usage Examples

```
üìã Task Manager> add "Complete C++23 demo" high
‚úÖ Task added successfully with ID: 1

üìã Task Manager> add "Review code" medium  
‚úÖ Task added successfully with ID: 2

üìã Task Manager> list
üìã Task List (2 tasks):
==================================================
üéØ #1: Complete C++23 demo [Pending] (High)
üéØ #2: Review code [Pending] (Medium)

üìã Task Manager> status 1 completed
‚úÖ Task 1 status updated successfully.

üìã Task Manager> filter status completed
üîç Filtered Tasks (status = completed):
==================================================
üéØ #1: Complete C++23 demo [Completed] (High)

üìã Task Manager> matrix
üî¢ Task Matrix View:
==================================================
Task Matrix View (2 x 2):
Format: [ID, Priority]
Task 1: [ID: 1, Priority: 8]
Task 2: [ID: 2, Priority: 5]

üìã Task Manager> help
üìö Available Commands:
==================================================
  add          - Add a new task: add <description> [priority]
  list         - List all tasks: list [status|priority]
  remove       - Remove a task: remove <id>
  update       - Update task description: update <id> <new_description>
  status       - Change task status: status <id> <new_status>
  priority     - Change task priority: priority <id> <new_priority>
  filter       - Filter tasks: filter <status|priority> <value>
  matrix       - Show task matrix view: matrix
  help         - Show help: help
  exit         - Exit the application: exit
```

## üéØ Features

- ‚úÖ Add/Remove/Update tasks
- ‚úÖ Set task priorities (Low, Medium, High, Critical)
- ‚úÖ Change task status (Pending, InProgress, Completed, Cancelled)
- ‚úÖ Filter tasks by status or priority
- ‚úÖ Matrix view of task data using std::mdspan
- ‚úÖ Modern error handling with std::expected
- ‚úÖ Rich CLI interface with emoji and colors
- ‚úÖ All 10 C++23 techniques integrated
- ‚úÖ JSON serialization/deserialization with std::expected
- ‚úÖ Modern error handling for file I/O operations

## üéØ JSON Implementation C++23 Features

### Enhanced Error Handling v·ªõi std::expected
```cpp
enum class JsonError {
    FileNotFound,
    InvalidFormat, 
    WriteError,
    ParseError
};

using JsonResult = std::expected<bool, JsonError>;

JsonResult saveToJson(const std::string& filename) const;
JsonResult loadFromJson(const std::string& filename);
```

### Modern String Formatting v·ªõi std::format
```cpp
json << std::format("  \"id\": {},\n", _id);
json << std::format("  \"title\": \"{}\",\n", escapeJsonString(_title));
json << std::format("  \"priority\": {},\n", _metadata.priority);
```

### Concepts-Based Validation
```cpp
template<typename T>
concept JsonSerializable = requires(T t) {
    { t.toJson() } -> std::convertible_to<std::string>;
};
```

## üèóÔ∏è Architecture

```
App (CLI Interface)
‚îú‚îÄ‚îÄ TaskManager (Business Logic)
    ‚îú‚îÄ‚îÄ Task (Data Model)
    ‚îî‚îÄ‚îÄ Error Handling (std::expected)
```

## üìù Notes

- M·ªôt s·ªë features c·ªßa C++23 c√≥ th·ªÉ ch∆∞a ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·∫ßy ƒë·ªß tr√™n t·∫•t c·∫£ compilers
- std::print v√† std::expected c√≥ th·ªÉ c·∫ßn implementations thay th·∫ø cho c√°c compiler c≈©
- std::mdspan c√≥ th·ªÉ c·∫ßn include ri√™ng ho·∫∑c s·ª≠ d·ª•ng experimental namespace

## üîÆ Future Enhancements

- ‚úÖ L∆∞u tasks v√†o file JSON (IMPLEMENTED)
- Task scheduling v·ªõi std::chrono
- Multi-threading v·ªõi std::jthread
- Network sync capabilities
- GUI interface

## üíæ JSON Serialization Features

·ª®ng d·ª•ng hi·ªán h·ªó tr·ª£ l∆∞u v√† t·∫£i tasks t·ª´ file JSON v·ªõi c√°c t√≠nh nƒÉng:

### Save Tasks
```bash
save [filename]        # L∆∞u t·∫•t c·∫£ tasks, m·∫∑c ƒë·ªãnh: tasks.json
save my_tasks.json     # L∆∞u v·ªõi t√™n file t√πy ch·ªânh
```

### Load Tasks  
```bash
load [filename]        # T·∫£i tasks, m·∫∑c ƒë·ªãnh: tasks.json
load my_tasks.json     # T·∫£i t·ª´ file t√πy ch·ªânh
```

### JSON Format
File JSON ƒë∆∞·ª£c structured nh∆∞ sau:
```json
{
  "version": "1.0",
  "next_id": 4,
  "tasks": [
    {
      "id": 1,
      "title": "Task title", 
      "description": "Task description",
      "status": "Pending",
      "category": "General",
      "priority": 0,
      "created_at": "2025-07-01T09:47:10.015Z",
      "updated_at": "2025-07-01T09:47:10.015Z",
      "completed_at": "2025-07-01T09:47:10.015Z"  // optional
    }
  ]
}
```

### Features
- ‚úÖ **Auto-save ID tracking**: Preserves next available ID
- ‚úÖ **ISO 8601 timestamps**: Standard datetime format
- ‚úÖ **Complete task metadata**: All task properties preserved  
- ‚úÖ **Error handling**: Robust file I/O with meaningful error messages
- ‚úÖ **UTF-8 support**: Proper string escaping for international characters
- ‚úÖ **Backup-friendly**: Human-readable JSON format